{
  "name": "Index Document for RAG",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "index-document",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [240, 300],
      "webhookId": "index-document-webhook"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  d.id,\n  d.title,\n  d.document_type,\n  d.file_path,\n  d.mime_type,\n  d.property_id,\n  d.unit_id,\n  d.tenant_id,\n  d.metadata,\n  p.name as property_name,\n  p.street as property_street\nFROM documents d\nLEFT JOIN properties p ON p.id = d.property_id\nWHERE d.id = '{{ $json.body.document_id }}'::UUID\n  AND d.is_indexed = false",
        "options": {}
      },
      "id": "get-document",
      "name": "Get Document Metadata",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [460, 300],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "NG1j8CLMwUIHYhaW",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-exists",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-document-exists",
      "name": "Document Exists?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/storage/v1/object/{{ $json.file_path }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "id": "download-file",
      "name": "Download from Supabase Storage",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 200]
    },
    {
      "parameters": {
        "url": "http://docling:5001/v1/convert/file",
        "method": "POST",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "files",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "convert-docling",
      "name": "Convert via Docling",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "jsCode": "// Extract markdown content from Docling response\nconst input = $input.first().json;\nconst document = $('Get Document Metadata').first().json;\n\nlet markdownContent = '';\n\nif (input.document && input.document.md_content) {\n  markdownContent = input.document.md_content;\n} else if (input.document && input.document.export_results && input.document.export_results.markdown) {\n  markdownContent = input.document.export_results.markdown;\n} else if (input.output && input.output.markdown) {\n  markdownContent = input.output.markdown;\n} else if (input.content) {\n  markdownContent = input.content;\n} else if (typeof input === 'string') {\n  markdownContent = input;\n} else {\n  const findMarkdown = (obj, depth = 0) => {\n    if (depth > 5 || !obj) return '';\n    if (typeof obj === 'string' && obj.length > 50) return obj;\n    if (typeof obj === 'object') {\n      for (const key of ['md_content', 'markdown', 'text', 'content', 'output']) {\n        if (obj[key] && typeof obj[key] === 'string' && obj[key].length > 50) return obj[key];\n      }\n      for (const key of Object.keys(obj)) {\n        const result = findMarkdown(obj[key], depth + 1);\n        if (result) return result;\n      }\n    }\n    return '';\n  };\n  markdownContent = findMarkdown(input);\n}\n\nif (!markdownContent || markdownContent.length < 50) {\n  return {\n    error: true,\n    message: `Docling: kein Content (${markdownContent ? markdownContent.length : 0} Zeichen)`\n  };\n}\n\nreturn {\n  document_id: document.id,\n  title: document.title,\n  document_type: document.document_type,\n  property_id: document.property_id,\n  property_name: document.property_name,\n  property_street: document.property_street,\n  unit_id: document.unit_id,\n  tenant_id: document.tenant_id,\n  extracted_text: markdownContent,\n  text_length: markdownContent.length,\n  metadata: document.metadata || {}\n};"
      },
      "id": "extract-text",
      "name": "Extract Text from Docling",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "jsCode": "// Parse extracted text and create chunks\nconst input = $input.first().json;\n\nif (input.error) {\n  return { error: input.message };\n}\n\nconst text = input.extracted_text || '';\n\nif (!text || text.length < 50) {\n  return { error: 'Extracted text too short or empty' };\n}\n\nconst CHARS_PER_TOKEN = 4;\nconst CHUNK_SIZE_CHARS = 500 * CHARS_PER_TOKEN; // 2000 chars\nconst OVERLAP_CHARS = 50 * CHARS_PER_TOKEN;     // 200 chars\n\n// Markdown-aware chunking: split on headings first\nconst sections = text.split(/(?=^#{1,3}\\s)/m);\nconst chunks = [];\nlet currentChunk = '';\nlet currentSection = '';\nlet chunkIndex = 0;\n\nfor (const section of sections) {\n  const headingMatch = section.match(/^(#{1,3})\\s+(.+)/m);\n  if (headingMatch) {\n    currentSection = headingMatch[2].trim();\n  }\n\n  const sentences = section.split(/(?<=[.!?])\\s+/);\n\n  for (const sentence of sentences) {\n    if (currentChunk.length + sentence.length > CHUNK_SIZE_CHARS && currentChunk.length > 0) {\n      chunks.push({\n        chunk_index: chunkIndex,\n        content: currentChunk.trim(),\n        section_title: currentSection,\n        char_count: currentChunk.length,\n        approx_tokens: Math.ceil(currentChunk.length / CHARS_PER_TOKEN)\n      });\n\n      const overlapStart = Math.max(0, currentChunk.length - OVERLAP_CHARS);\n      currentChunk = currentChunk.substring(overlapStart) + ' ' + sentence;\n      chunkIndex++;\n    } else {\n      currentChunk += (currentChunk ? ' ' : '') + sentence;\n    }\n  }\n}\n\nif (currentChunk.trim().length > 0) {\n  chunks.push({\n    chunk_index: chunkIndex,\n    content: currentChunk.trim(),\n    section_title: currentSection,\n    char_count: currentChunk.length,\n    approx_tokens: Math.ceil(currentChunk.length / CHARS_PER_TOKEN)\n  });\n}\n\nreturn {\n  document_id: input.document_id,\n  title: input.title,\n  document_type: input.document_type,\n  property_id: input.property_id,\n  property_name: input.property_name,\n  unit_id: input.unit_id,\n  tenant_id: input.tenant_id,\n  total_chars: text.length,\n  total_chunks: chunks.length,\n  chunks: chunks,\n  metadata: {\n    ...input.metadata,\n    property_street: input.property_street,\n    indexed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "chunk-text",
      "name": "Chunk Text (500 tokens, 50 overlap)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "jsCode": "// Split chunks into individual items for parallel embedding\nconst data = $input.first().json;\n\nif (data.error) {\n  return [{ json: data }];\n}\n\nconst items = data.chunks.map(chunk => ({\n  json: {\n    document_id: data.document_id,\n    title: data.title,\n    document_type: data.document_type,\n    property_id: data.property_id,\n    unit_id: data.unit_id,\n    tenant_id: data.tenant_id,\n    chunk_index: chunk.chunk_index,\n    content: chunk.content,\n    total_chunks: data.total_chunks,\n    metadata: data.metadata\n  }\n}));\n\nreturn items;"
      },
      "id": "split-chunks",
      "name": "Split Into Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 200]
    },
    {
      "parameters": {
        "batchSize": 10,
        "options": {}
      },
      "id": "batch-chunks",
      "name": "Batch Chunks",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [2000, 200]
    },
    {
      "parameters": {
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": {{ JSON.stringify($json.content) }},\n  \"dimensions\": 1536\n}",
        "options": {}
      },
      "id": "create-embedding",
      "name": "Create OpenAI Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 200],
      "credentials": {
        "openAiApi": {
          "id": "2gJYiwjzGma3vMh1",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Combine chunk data with embedding\nconst chunkData = $('Batch Chunks').first().json;\nconst embeddingResponse = $input.first().json;\n\nif (!embeddingResponse.data || !embeddingResponse.data[0]) {\n  return { error: 'No embedding received from OpenAI' };\n}\n\nconst embedding = embeddingResponse.data[0].embedding;\n\nreturn {\n  document_id: chunkData.document_id,\n  chunk_index: chunkData.chunk_index,\n  content: chunkData.content,\n  embedding: `[${embedding.join(',')}]`,\n  metadata: JSON.stringify({\n    ...chunkData.metadata,\n    title: chunkData.title,\n    document_type: chunkData.document_type,\n    property_id: chunkData.property_id,\n    unit_id: chunkData.unit_id,\n    tenant_id: chunkData.tenant_id,\n    total_chunks: chunkData.total_chunks\n  })\n};"
      },
      "id": "prepare-embedding-data",
      "name": "Prepare Embedding Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO document_embeddings (\n  document_id,\n  chunk_index,\n  content,\n  embedding,\n  metadata\n) VALUES (\n  '{{ $json.document_id }}'::UUID,\n  {{ $json.chunk_index }},\n  $content${{ $json.content }}$content$,\n  '{{ $json.embedding }}'::vector(1536),\n  '{{ $json.metadata }}'::JSONB\n)\nON CONFLICT (document_id, chunk_index) DO UPDATE SET\n  content = EXCLUDED.content,\n  embedding = EXCLUDED.embedding,\n  metadata = EXCLUDED.metadata",
        "options": {}
      },
      "id": "insert-embedding",
      "name": "Insert Embedding",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2660, 200],
      "credentials": {
        "postgres": {
          "id": "NG1j8CLMwUIHYhaW",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-done",
              "leftValue": "={{ $('Batch Chunks').first().context.noItemsLeft }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-all-done",
      "name": "All Chunks Done?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2880, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE documents \nSET is_indexed = true\nWHERE id = '{{ $('Get Document Metadata').first().json.id }}'::UUID\nRETURNING id, title, is_indexed",
        "options": {}
      },
      "id": "mark-indexed",
      "name": "Mark Document as Indexed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3100, 100],
      "credentials": {
        "postgres": {
          "id": "NG1j8CLMwUIHYhaW",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"document_id\": \"{{ $('Get Document Metadata').first().json.id }}\",\n  \"title\": \"{{ $('Get Document Metadata').first().json.title }}\",\n  \"chunks_created\": {{ $('Chunk Text (500 tokens, 50 overlap)').first().json.total_chunks }},\n  \"message\": \"Document indexed successfully\"\n}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3540, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"Document not found or already indexed\",\n  \"document_id\": \"{{ $('Webhook Trigger').first().json.body.document_id }}\"\n}",
        "options": {
          "responseCode": 404
        }
      },
      "id": "respond-not-found",
      "name": "Respond Not Found",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 400]
    },
    {
      "parameters": {},
      "id": "no-op-end",
      "name": "End",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [3760, 200]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Get Document Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Document Metadata": {
      "main": [
        [
          {
            "node": "Document Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Exists?": {
      "main": [
        [
          {
            "node": "Download from Supabase Storage",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Not Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download from Supabase Storage": {
      "main": [
        [
          {
            "node": "Convert via Docling",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert via Docling": {
      "main": [
        [
          {
            "node": "Extract Text from Docling",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text from Docling": {
      "main": [
        [
          {
            "node": "Chunk Text (500 tokens, 50 overlap)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Text (500 tokens, 50 overlap)": {
      "main": [
        [
          {
            "node": "Split Into Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Items": {
      "main": [
        [
          {
            "node": "Batch Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Chunks": {
      "main": [
        [
          {
            "node": "Create OpenAI Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create OpenAI Embedding": {
      "main": [
        [
          {
            "node": "Prepare Embedding Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Embedding Data": {
      "main": [
        [
          {
            "node": "Insert Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Embedding": {
      "main": [
        [
          {
            "node": "All Chunks Done?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "All Chunks Done?": {
      "main": [
        [
          {
            "node": "Mark Document as Indexed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Batch Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Document as Indexed": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond Success": {
      "main": [
        [
          {
            "node": "End",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond Not Found": {
      "main": [
        [
          {
            "node": "End",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "versionId": "2",
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "life-os"
  },
  "tags": [
    {
      "name": "ai-copilot",
      "id": "ai-copilot-tag"
    },
    {
      "name": "rag",
      "id": "rag-tag"
    },
    {
      "name": "documents",
      "id": "documents-tag"
    }
  ],
  "pinData": {},
  "staticData": null,
  "triggerCount": 0
}
